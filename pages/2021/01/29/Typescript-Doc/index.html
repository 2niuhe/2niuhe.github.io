<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="author" content="niuhe" />
    <meta name="robots" content="index, follow"/>

    <meta property="og:title" content="Typescript 基础"/>
    <meta property="og:url" content="../../../../../pages/2021/01/29/Typescript-Doc/"/>
    <meta property="og:site_name" content="Niuhe's Blog"/>
    <meta property="og:type" content="article"/>

    <link rel="canonical" href="../../../../../pages/2021/01/29/Typescript-Doc/" />

    <title>Typescript 基础 | Niuhe's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?">
    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />

    <link rel="stylesheet" type="text/css" href="../../../../../theme/css/main.css" />

    <script type="text/javascript">var switchTo5x=true;</script>
    <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">
        stLight.options({
            publisher: "",
            doNotHash: false,
            doNotCopy: false,
            hashAddressBar: false
        });
    </script>
</head>

<body id="index">
<a class="hidden-phone" href="https://github.com/2niuhe">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub" />
</a>
    <div class="row-fluid">
        <div class="span10 offset1">
            <header id="banner" >
                <h1>
                    <a href="../../../../../">Niuhe's Blog </a>
                </h1>
                <nav class="navbar">
                    <div class="navbar-inner">
                        <ul class="nav">
                            <li class="active"><a href="../../../../../category/angular.html">Angular</a></li>
                            <li ><a href="../../../../../category/arduino.html">Arduino</a></li>
                            <li ><a href="../../../../../category/go.html">Go</a></li>
                            <li ><a href="../../../../../category/golang.html">Golang</a></li>
                            <li ><a href="../../../../../category/life.html">Life : )</a></li>
                            <li ><a href="../../../../../category/linux.html">Linux</a></li>
                            <li ><a href="../../../../../category/openstack.html">Openstack</a></li>
                            <li ><a href="../../../../../category/others.html">Others</a></li>
                            <li ><a href="../../../../../category/python.html">Python</a></li>
                            <li ><a href="../../../../../category/raspberry.html">Raspberry</a></li>
                            <li ><a href="../../../../../category/ros.html">ROS</a></li>
                        </ul>

                    </div>
                </nav>
            </header><!-- /#banner -->
        </div>
    </div>

    <div class="row-fluid">
        <div class="span10 offset1">
            <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="../../../../../pages/2021/01/29/Typescript-Doc/" rel="bookmark"
             title="Permalink to Typescript 基础">Typescript 基础</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../../../../../author/niuhe.html">niuhe</a>
    </address>

    in <a href="../../../../../category/angular.html">Angular</a>

    on 2021-01-29

        |
        tags:         <a href="../../../../../tag/typescript.html">Typescript</a>


        |
        <a href="../../../../../pages/2021/01/29/Typescript-Doc/#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->

        <h3>简介</h3>
<blockquote>
<p>Typescript 可以在代码编写写做类型检查，可以编写更健壮的代码。</p>
</blockquote>
<h3>安装</h3>
<div class="highlight"><pre><span></span><code>npm config <span class="nb">set</span> registry https://registry.npm.taobao.org
sudo npm install -g typescript
<span class="c1"># 安装REPL</span>
sudo npm install -g tsun
</code></pre></div>


<h3>基本概念</h3>
<p><strong>联合类型</strong></p>
<blockquote>
<p>表示取值是多种类型中的一种，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">myFavoriteNumber</span>: <span class="kt">string</span> <span class="o">|</span> <span class="kt">number</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="s2">&quot;seven&quot;</span><span class="p">;</span>
<span class="nx">myFavoriteNumber</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</code></pre></div>


<p><strong>接口</strong></p>
<blockquote>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。
接口是一个类型，不是一个真正的值，它在编译结果中会被删除</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//？可选属性</span>
<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">age?</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">tom</span>: <span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Tom&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">tom</span>: <span class="kt">Person1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Tom&quot;</span><span class="p">,</span>
  <span class="nx">age</span>: <span class="kt">25</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">//接口可以继承</span>
<span class="kr">interface</span> <span class="nx">ApiError</span> <span class="kr">extends</span> <span class="nb">Error</span> <span class="p">{</span>
  <span class="nx">code</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<blockquote>
<p>接口可以定义任意类型，但是当同时存在可选类型和任意类型，可选类型需要是任意类型的子集</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">age?</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="c1">//任意类型为联合类型</span>
  <span class="p">[</span><span class="nx">propName</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">string</span> <span class="o">|</span> <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">tom</span>: <span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Tom&quot;</span><span class="p">,</span>
  <span class="nx">age</span>: <span class="kt">25</span><span class="p">,</span>
  <span class="nx">gender</span><span class="o">:</span> <span class="s2">&quot;male&quot;</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>


<blockquote>
<p>接口属性只读，意味着，只有在创建对象时可被赋值，其后无法修改，而且只读属性必须在对象初始化时进行赋值。</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">readonly</span> <span class="nx">id</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">age?</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="p">[</span><span class="nx">propName</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="nx">any</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">tom</span>: <span class="kt">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">id</span>: <span class="kt">89757</span><span class="p">,</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Tom&quot;</span><span class="p">,</span>
  <span class="nx">gender</span><span class="o">:</span> <span class="s2">&quot;male&quot;</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>


<p><strong>数组</strong></p>
<blockquote>
<p>习惯性的将数组中的元素类型保持相同</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">fibonacci</span>: <span class="kt">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="c1">//泛型</span>
<span class="kd">let</span> <span class="nx">fibonacci</span>: <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="c1">//接口表示数组</span>
<span class="c1">//用接口表示数组通常用来标识类型</span>
<span class="kr">interface</span> <span class="nx">NumberArray</span> <span class="p">{</span>
  <span class="c1">//索引是数字，类型是数字</span>
  <span class="p">[</span><span class="nx">index</span>: <span class="kt">number</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">fibonacci</span>: <span class="kt">NumberArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

<span class="kr">interface</span> <span class="nx">IArguments</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">index</span>: <span class="kt">number</span><span class="p">]</span><span class="o">:</span> <span class="nx">any</span><span class="p">;</span>
  <span class="nx">length</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="nx">callee</span>: <span class="kt">Function</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p><strong>函数</strong></p>
<blockquote>
<p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）;
函数声明和函数表达式的词法环境和执行上下文是不一样的，函数声明会做类型提升。</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// 函数声明（Function Declaration）</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 函数表达式（Function Expression）</span>
<span class="kd">let</span> <span class="nx">mySum</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>


<blockquote>
<p>可以手动给函数表达式添加类型，也可以使用类型推断
在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。
在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">mySum</span><span class="o">:</span> <span class="p">(</span><span class="nx">x</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">number</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span>
  <span class="nx">x</span>: <span class="kt">number</span><span class="p">,</span>
  <span class="nx">y</span>: <span class="kt">number</span>
<span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>


<blockquote>
<p>可选参数用？标识，必须接在必需参数的后面</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">buildName</span><span class="p">(</span><span class="nx">firstName</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">lastName?</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">lastName</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">firstName</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nx">lastName</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">firstName</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">tomcat</span> <span class="o">=</span> <span class="nx">buildName</span><span class="p">(</span><span class="s2">&quot;Tom&quot;</span><span class="p">,</span> <span class="s2">&quot;Cat&quot;</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">tom</span> <span class="o">=</span> <span class="nx">buildName</span><span class="p">(</span><span class="s2">&quot;Tom&quot;</span><span class="p">);</span>
</code></pre></div>


<blockquote>
<p>ES6 中允许给参数添加默认值，Typescript 将添加默认值的参数识别为可选参数，并且添加默认值后，就不受「可选参数必须接在必需参数后面」的限制了
默认值参数在必需参数前的话，需要传一个 undefined 进去占位，因此推荐将默认值参数放在后面</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">buildName</span><span class="p">(</span><span class="nx">firstName</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;Tom&quot;</span><span class="p">,</span> <span class="nx">lastName</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">firstName</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nx">lastName</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">tomcat</span> <span class="o">=</span> <span class="nx">buildName</span><span class="p">(</span><span class="s2">&quot;Tom&quot;</span><span class="p">,</span> <span class="s2">&quot;Cat&quot;</span><span class="p">);</span>
<span class="c1">//如果默认值参数在必需参数前边，必须传入undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">buildName</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">));</span>

<span class="kd">function</span> <span class="nx">buildName1</span><span class="p">(</span><span class="nx">firstName</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">lastName</span>: <span class="kt">string</span> <span class="o">=</span> <span class="s2">&quot;Man&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">firstName</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nx">lastName</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">buildName</span><span class="p">(</span><span class="s2">&quot;good&quot;</span><span class="p">));</span>
</code></pre></div>


<blockquote>
<p>剩余 rest 参数（不定长参数）
rest 参数只能是最后一个参数</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//items是一个数组</span>
<span class="kd">function</span> <span class="nx">push</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="p">...</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">items</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">array</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span>: <span class="kt">any</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div>


<blockquote>
<p>函数重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。
Typescript 会从最前面的函数定义开始匹配</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//前声明（定义）后实现，将精确的声明写在前面</span>
<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">string</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">reverse</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">number</span> <span class="o">|</span> <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kt">number</span> <span class="o">|</span> <span class="kt">string</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">toString</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span> <span class="o">===</span> <span class="s2">&quot;string&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p><strong>类型断言</strong></p>
<blockquote>
<p>值 as 类型
类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除
它不会真的影响到变量的类型。
应用场景:</p>
<ul>
<li>将一个联合类型断言为其中一个类型，欺骗 tsc 编译器，可能导致运行时出错</li>
<li>将一个父类断言为更加具体的子类</li>
<li>将任何一个类型断言为 any</li>
<li>将 any 断言为一个具体的类型</li>
</ul>
<p>限制：
typescript 是结构类型系统，不关心定义时的类型关系，只比较最终结构有什么关系</p>
<ul>
<li>联合类型可以被断言为其中一个类型</li>
<li>父类可以被断言为子类</li>
<li>任何类型都可以被断言为 any</li>
<li>any 可以被断言为任何类型</li>
<li>要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可</li>
</ul>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//类型比较</span>
<span class="c1">//下面两种Cat的定义是等价的</span>
<span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span> <span class="nx">Cat</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">run</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Cat</span> <span class="kr">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nx">run</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="c1">//联合类型断言</span>
<span class="kr">interface</span> <span class="nx">Cat</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">run</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span> <span class="nx">Fish</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">swim</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isFish</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Cat</span> <span class="o">|</span> <span class="nx">Fish</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="p">(</span><span class="nx">animal</span> <span class="kr">as</span> <span class="nx">Fish</span><span class="p">).</span><span class="nx">swim</span> <span class="o">===</span> <span class="s2">&quot;function&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="c1">//子类断言</span>
<span class="kr">interface</span> <span class="nx">ApiError</span> <span class="kr">extends</span> <span class="nb">Error</span> <span class="p">{</span>
  <span class="nx">code</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span> <span class="nx">HttpError</span> <span class="kr">extends</span> <span class="nb">Error</span> <span class="p">{</span>
  <span class="nx">statusCode</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">isApiError</span><span class="p">(</span><span class="nx">error</span>: <span class="kt">Error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="p">(</span><span class="nx">error</span> <span class="kr">as</span> <span class="nx">ApiError</span><span class="p">).</span><span class="nx">code</span> <span class="o">===</span> <span class="s2">&quot;number&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="c1">//确保代码无误后，绕过类型检查</span>
<span class="c1">//在类型的严格性和开发的便利性之间掌握平衡</span>
<span class="p">(</span><span class="nb">window</span> <span class="kr">as</span> <span class="nx">any</span><span class="p">).</span><span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="c1">//明确类型，后续有了代码补全，提高可维护性</span>
<span class="kd">function</span> <span class="nx">getCacheData</span><span class="p">(</span><span class="nx">key</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">window</span> <span class="kr">as</span> <span class="nx">any</span><span class="p">).</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Cat</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">run</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">tom</span> <span class="o">=</span> <span class="nx">getCacheData</span><span class="p">(</span><span class="s2">&quot;tom&quot;</span><span class="p">)</span> <span class="kr">as</span> <span class="nx">Cat</span><span class="p">;</span>
<span class="nx">tom</span><span class="p">.</span><span class="nx">run</span><span class="p">();</span>
</code></pre></div>


<blockquote>
<p>类型声明比类型断言约束更严格，如
animal 断言为 Cat，只需要满足 Animal 兼容 Cat 或 Cat 兼容 Animal 即可
animal 赋值给 tom，需要满足 Cat 兼容 Animal 才行
可以用泛型替代类型断言</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">getCacheData</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">key</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">window</span> <span class="kr">as</span> <span class="nx">any</span><span class="p">).</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Cat</span> <span class="p">{</span>
  <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">run</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">tom</span> <span class="o">=</span> <span class="nx">getCacheData</span><span class="o">&lt;</span><span class="nx">Cat</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;tom&quot;</span><span class="p">);</span>
<span class="nx">tom</span><span class="p">.</span><span class="nx">run</span><span class="p">();</span>
</code></pre></div>


<p><strong>声明文件</strong></p>
<blockquote>
<p>常用的声明语法</p>
<ul>
<li>declare var 声明全局变量</li>
<li>declare const 声明全局常量</li>
<li>declare function 声明全局方法</li>
<li>declare class 声明全局类</li>
<li>declare enum 声明全局枚举类型</li>
<li>declare namespace 声明（含有子属性的）全局对象</li>
<li>interface 和 type 声明全局类型</li>
<li>export 导出变量</li>
<li>export namespace 导出（含有子属性的）对象</li>
<li>export default ES6 默认导出</li>
<li>export = commonjs 导出模块</li>
<li>export as namespace UMD 库声明全局变量</li>
<li>declare global 扩展全局变量</li>
<li>declare module 扩展模块</li>
<li>/// <code>&lt;reference /&gt;</code> 三斜线指令</li>
</ul>
</blockquote>
<p><strong>类型别名</strong></p>
<blockquote>
<p>类型 c 语言 typedef，在 typescript 中用 type 创建类型别名</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="nx">type</span> <span class="nx">Name</span> <span class="o">=</span> <span class="kt">string</span><span class="p">;</span>
<span class="nx">type</span> <span class="nx">NameResolver</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="kt">string</span><span class="p">;</span>
<span class="nx">type</span> <span class="nx">NameOrResolver</span> <span class="o">=</span> <span class="nx">Name</span> <span class="o">|</span> <span class="nx">NameResolver</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">getName</span><span class="p">(</span><span class="nx">n</span>: <span class="kt">NameOrResolver</span><span class="p">)</span><span class="o">:</span> <span class="nx">Name</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="s2">&quot;string&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<p><strong>字面量类型</strong></p>
<blockquote>
<p>约束取值只能是某几个值中的一个</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="nx">type</span> <span class="nx">EventNames</span> <span class="o">=</span> <span class="s2">&quot;click&quot;</span> <span class="o">|</span> <span class="s2">&quot;scroll&quot;</span> <span class="o">|</span> <span class="s2">&quot;mousemove&quot;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">handleEvent</span><span class="p">(</span><span class="nx">ele</span>: <span class="kt">Element</span><span class="p">,</span> <span class="nx">event</span>: <span class="kt">EventNames</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do something</span>
<span class="p">}</span>

<span class="nx">handleEvent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">),</span> <span class="s2">&quot;scroll&quot;</span><span class="p">);</span> <span class="c1">// 没问题</span>
<span class="nx">handleEvent</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;world&quot;</span><span class="p">),</span> <span class="s2">&quot;dblclick&quot;</span><span class="p">);</span> <span class="c1">// 报错，event 不能为 &#39;dblclick&#39;</span>
</code></pre></div>


<p><strong>元组</strong></p>
<blockquote>
<p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象;
可以对元组中的单个元素赋值；
当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项;
当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">tom</span><span class="o">:</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Tom&quot;</span><span class="p">,</span> <span class="mi">25</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">tom</span><span class="o">:</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">number</span><span class="p">];</span>
<span class="nx">tom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Tom&quot;</span><span class="p">;</span>
<span class="nx">tom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>

<span class="nx">tom</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">tom</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="nx">tom</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Tom&quot;</span><span class="p">,</span> <span class="mi">25</span><span class="p">];</span>
<span class="nx">tom</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&quot;male&quot;</span><span class="p">);</span>
</code></pre></div>


<p><strong>枚举</strong></p>
<blockquote>
<p>枚举（Enum）类型用于取值被限定在一定范围内的场景</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kr">enum</span> <span class="nx">Days</span> <span class="p">{</span>
  <span class="nx">Sun</span><span class="p">,</span>
  <span class="nx">Mon</span><span class="p">,</span>
  <span class="nx">Tue</span><span class="p">,</span>
  <span class="nx">Wed</span><span class="p">,</span>
  <span class="nx">Thu</span><span class="p">,</span>
  <span class="nx">Fri</span><span class="p">,</span>
  <span class="nx">Sat</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="s2">&quot;Sun&quot;</span><span class="p">]</span> <span class="o">===</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="s2">&quot;Mon&quot;</span><span class="p">]</span> <span class="o">===</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="s2">&quot;Tue&quot;</span><span class="p">]</span> <span class="o">===</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="s2">&quot;Sat&quot;</span><span class="p">]</span> <span class="o">===</span> <span class="mi">6</span><span class="p">);</span> <span class="c1">// true</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&quot;Sun&quot;</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&quot;Mon&quot;</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&quot;Tue&quot;</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Days</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&quot;Sat&quot;</span><span class="p">);</span> <span class="c1">// true</span>
</code></pre></div>


<p><strong>类</strong></p>
<blockquote>
<p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class
使用 class 定义类，使用 constructor 定义构造函数。
通过 new 生成新实例的时候，会自动调用构造函数。
使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。
使用 getter 和 setter 可以改变属性的赋值和读取行为：
使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用，不可以通过实例来调用：</p>
<p>ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义
ES7 提案中，可以使用 static 定义一个静态属性，静态属性属于类；
当构造函数修饰为 private 时，该类不允许被继承或者实例化;
当构造函数修饰为 protected 时，该类只允许被继承，不允许被实例化；
类属性/方法的访问限定符如下:</p>
<ul>
<li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li>
<li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li>
</ul>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kr">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kr">private</span> <span class="nx">_name</span>: <span class="kt">string</span><span class="p">;</span>
  <span class="nx">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
  <span class="kr">static</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="kr">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">get</span> <span class="nx">name() {</span>
    <span class="k">return</span> <span class="s2">&quot;get &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//name是public的，但是_name是私有的</span>
  <span class="c1">//不能在set name中再对name赋值，会造成死循环</span>
  <span class="nx">set</span> <span class="nx">name</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="s2">&quot;Dog&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Animal cannot be dog&quot;</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;setter: &quot;</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">sayHi() {</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`My name is </span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kr">static</span> <span class="nx">isAnimal</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="k">instanceof</span> <span class="nx">Animal</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Cat</span> <span class="kr">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kr">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// 调用父类的 constructor(name)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//函数重写</span>
  <span class="nx">sayHi() {</span>
    <span class="k">return</span> <span class="s2">&quot;Meow, &quot;</span> <span class="o">+</span> <span class="kr">super</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">();</span> <span class="c1">// 调用父类的 sayHi()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">(</span><span class="s2">&quot;Jack&quot;</span><span class="p">);</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">isAnimal</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// true</span>

<span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="s2">&quot;Tom&quot;</span><span class="p">);</span> <span class="c1">// Tom</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">sayHi</span><span class="p">());</span> <span class="c1">// Meow, My name is Tom</span>
</code></pre></div>


<blockquote>
<p>参数属性
修饰符和 readonly 还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值
只读属性关键字，只允许出现在属性声明或索引签名或构造函数中
注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。
abstract 用于定义抽象类和其中的抽象方法。
抽象类不允许被实例化，抽象类中的抽象方法必须被子类实现</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="c1">//public readonly name;</span>
  <span class="kr">public</span> <span class="kr">constructor</span><span class="p">(</span><span class="kr">public</span> <span class="nx">readonly</span> <span class="nx">name</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">//abstract method</span>
  <span class="kr">public</span> <span class="kr">abstract</span> <span class="nx">eat</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Cat</span> <span class="kr">extends</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="kr">public</span> <span class="nx">eat() {</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span><span class="sb"> is eating.`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="s2">&quot;Tom&quot;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Tom</span>
</code></pre></div>


<p><strong>类和接口</strong></p>
<blockquote>
<p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特
性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
<ul>
<li>接口中所有属性和方法都要求是 public</li>
<li>一个类可以实现一个或者多个接口</li>
<li>接口之间可以是继承关系</li>
<li>接口可以继承类（不推荐），本质上还是接口继承接口，因为在创建类的时候，会创建一个同名的接口类型</li>
</ul>
<p>创建类时自动生成的类型中包含了除了构造函数的实例属性和实例方法，会保留访问限定符，
如果类属性是 private，将导致该类型的对象无法被初始化，生成的接口类型中不包括：</p>
<ul>
<li>静态类型和静态方法</li>
<li>构造函数</li>
</ul>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kr">interface</span> <span class="nx">Alarm</span> <span class="p">{</span>
  <span class="nx">alert</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Light</span> <span class="p">{</span>
  <span class="nx">lightOn</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">lightOff</span><span class="p">()</span><span class="o">:</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Car</span> <span class="kr">implements</span> <span class="nx">Alarm</span><span class="p">,</span> <span class="nx">Light</span> <span class="p">{</span>
  <span class="nx">alert() {</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Car alert&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">lightOn() {</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Car light on&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">lightOff() {</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Car light off&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<blockquote>
<p>接口继承类（晦涩）</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">x</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="nx">y</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="kr">constructor</span><span class="p">(</span><span class="nx">x</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">PointInstanceType</span> <span class="p">{</span>
  <span class="nx">x</span>: <span class="kt">number</span><span class="p">;</span>
  <span class="nx">y</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 等价于 interface Point3d extends PointInstanceType</span>
<span class="kr">interface</span> <span class="nx">Point3d</span> <span class="kr">extends</span> <span class="nx">Point</span> <span class="p">{</span>
  <span class="nx">z</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">point3d</span>: <span class="kt">Point3d</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">z</span>: <span class="kt">3</span> <span class="p">};</span>
</code></pre></div>


<p><strong>泛型</strong></p>
<blockquote>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">createArray</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">length</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">value</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span>: <span class="kt">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">createArray</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">);</span> <span class="c1">// [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</span>

<span class="c1">//多个类型参数</span>

<span class="kd">function</span> <span class="nx">swap</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">tuple</span><span class="o">:</span> <span class="p">[</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="p">])</span><span class="o">:</span> <span class="p">[</span><span class="nx">U</span><span class="p">,</span> <span class="nx">T</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>
<span class="p">}</span>

<span class="nx">swap</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="s2">&quot;seven&quot;</span><span class="p">]);</span> <span class="c1">// [&#39;seven&#39;, 7]</span>
</code></pre></div>


<blockquote>
<p>泛型约束，可以使用其他类型约束，也可以在类型参数之间进行约束</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">function</span> <span class="nx">copyFields</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">U</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">target</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">source</span>: <span class="kt">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">id</span> <span class="k">in</span> <span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">target</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="nx">source</span><span class="p">)[</span><span class="nx">id</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">target</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">b</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">c</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">d</span>: <span class="kt">4</span> <span class="p">};</span>

<span class="nx">copyFields</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="p">{</span> <span class="nx">b</span>: <span class="kt">10</span><span class="p">,</span> <span class="nx">d</span>: <span class="kt">20</span> <span class="p">});</span>
</code></pre></div>


<h3>参考</h3>
<p><a href="https://ts.xcatliu.com/">Typescript 入门教程</a></p>
<p><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解Typescript</a></p>

      </div><!-- /.entry-content -->
      <div class="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_identifier = "pages/2021/01/29/Typescript-Doc/";
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//niuhemoon.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
      </div>

    </article>
  </section>
</div>
            </div>
        </div>
    </div>

    <footer id="site-footer">
        <div class="row-fluid">
            <div class="span10 offset1">
                <address>
                    <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                    </p>
                    <p>
                        <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                    </p>
                </address>
            </div>
        </div>
    </footer>

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-116933089-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'niuhemoon';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
    <script src="//code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>
</body>
</html>