<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="author" content="niuhe" />
    <meta name="robots" content="index, follow"/>

    <meta property="og:title" content="Linux系统性能测试"/>
    <meta property="og:url" content="../../../../../pages/2020/10/17/Linux-Peformence-Test/"/>
    <meta property="og:site_name" content="Niuhe's Blog"/>
    <meta property="og:type" content="article"/>

    <link rel="canonical" href="../../../../../pages/2020/10/17/Linux-Peformence-Test/" />

    <title>Linux系统性能测试 | Niuhe's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
    <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />

    <link rel="stylesheet" type="text/css" href="../../../../../theme/css/main.css" />

    <script type="text/javascript">var switchTo5x=true;</script>
    <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">
        stLight.options({
            publisher: "",
            doNotHash: false,
            doNotCopy: false,
            hashAddressBar: false
        });
    </script>
</head>

<body id="index">
<a class="hidden-phone" href="https://github.com/2niuhe">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub" />
</a>
    <div class="row-fluid">
        <div class="span10 offset1">
            <header id="banner" >
                <h1>
                    <a href="../../../../../">Niuhe's Blog </a>
                </h1>
                <nav class="navbar">
                    <div class="navbar-inner">
                        <ul class="nav">
                            <li ><a href="../../../../../category/arduino.html">Arduino</a></li>
                            <li ><a href="../../../../../category/life.html">Life : )</a></li>
                            <li class="active"><a href="../../../../../category/linux.html">Linux</a></li>
                            <li ><a href="../../../../../category/openstack.html">Openstack</a></li>
                            <li ><a href="../../../../../category/others.html">Others</a></li>
                            <li ><a href="../../../../../category/python.html">Python</a></li>
                            <li ><a href="../../../../../category/raspberry.html">Raspberry</a></li>
                            <li ><a href="../../../../../category/ros.html">ROS</a></li>
                        </ul>

                    </div>
                </nav>
            </header><!-- /#banner -->
        </div>
    </div>

    <div class="row-fluid">
        <div class="span10 offset1">
            <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="../../../../../pages/2020/10/17/Linux-Peformence-Test/" rel="bookmark"
             title="Permalink to Linux系统性能测试">Linux系统性能测试</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../../../../../author/niuhe.html">niuhe</a>
    </address>

    in <a href="../../../../../category/linux.html">Linux</a>

    on 2020-10-17

        |
        tags:         <a href="../../../../../tag/linux.html">Linux</a>


        |
        <a href="../../../../../pages/2020/10/17/Linux-Peformence-Test/#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->

        <h3>简介</h3>
<blockquote>
<p>Linux上对系统进行性能检测的工具非常多，本文介绍一些常用工具的使用</p>
</blockquote>
<p>性能观测工具</p>
<p><img alt="img" src="img/f_3c65934a804b2cd6ec6dab02ccb33457.png"></p>
<blockquote>
<p>▪ 首先学习的Basic Tool有如下：
uptime、top(htop)、mpstat、isstat、vmstat、free、ping、nicstat、dstat。</p>
<p>▪ 高级的命令如下：
sar、netstat、pidstat、strace、tcpdump、blktrace、iotop、slabtop、sysctl、/proc。</p>
</blockquote>
<p>性能观测工具sar</p>
<p><img alt="img" src="img/f_33718c31204bfbe49a13dea6d0f3531f.png"></p>
<p>sar</p>
<div class="highlight"><pre><span></span><code><span class="c1"># install</span>
sudo apt install sysstat
<span class="c1"># usage</span>
sar -u <span class="m">2</span> <span class="m">3</span>
sar -u -f /var/log/sa/sa05
sar -P ALL <span class="m">1</span> <span class="m">1</span>
sar -r <span class="m">1</span> <span class="m">3</span>
sar -W <span class="m">1</span> <span class="m">3</span>
</code></pre></div>


<p>top</p>
<div class="highlight"><pre><span></span><code>交互模式的一些快捷操作:

    全局命令: &lt;回车/空格&gt; ?, <span class="o">=</span>, A, B, d, G, h, I, k, q, r, s, W, Z
    统计区的命令: l, m, t, <span class="m">1</span>
    任务区的命令：
         外观: b, x, y, z 内容: c, f, H, o, S, u 大小: <span class="c1">#, i, n 排序: &lt;, &gt;, F, O, R</span>
    色彩方案: &lt;Ret&gt;, a, B, b, H, M, q, S, T, w, z, <span class="m">0</span> - <span class="m">7</span>
    窗口命令:  -, _, <span class="o">=</span>, +, A, a, G, g, w

    Press <span class="s1">&#39;h&#39;</span> or <span class="s1">&#39;?&#39;</span> <span class="k">for</span> <span class="nb">help</span> with Windows,
Type <span class="s1">&#39;q&#39;</span> or &lt;Esc&gt; to <span class="k">continue</span> 
</code></pre></div>


<div class="highlight"><pre><span></span><code>
</code></pre></div>


<p>如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了！！！！！</p>
<h4>9. netstat - 显示开放的端口和连接</h4>
<p>它是<strong>Linux管理员</strong>使用来显示各种网络信息的工具，如查看什么端口开放和什么网络连接已经建立以及何种进程运行在该连接之上。同时它也显示了不同程序间打开的<strong>Unix套接字</strong>的信息。作为大多数Linux发行版本的一部分，netstat的许多命令在<a href="http://linux.cn/article-2434-1.html">netstat和它的不同输出</a>中有详细的描述。最为常用的如下：</p>
<div class="highlight"><pre><span></span><code>netstat <span class="p">|</span> head -20
netstat -r
netstat -rC
netstat -i
netstat -ie
netstat -s
netstat -g
netstat -tapn
</code></pre></div>


<p><strong>vmstat</strong>是虚拟内存(<strong>virtual memory</strong> statistics)的缩写，作为一个<strong>内存监控</strong>工具，它收集和显示关于<strong>内存</strong>，<strong>进程</strong>，<strong>终端</strong>和<strong>分页</strong>和<strong>I/O阻塞</strong>的概括信息。作为一个开源程序，它可以在大部分Linux发行版本中找到，包括Solaris和FreeBSD。它用来诊断大部分的内存性能问题和其他相关问题。</p>
<p>让我们看下如何了解vmstat提供的信息：</p>
<div class="highlight"><pre><span></span><code><span class="err">-----------------------------</span>
<span class="err">procs部分的解释</span>
<span class="err">r 列表示运行和等待cpu时间片的进程数，如果长期大于1，说明cpu不足，需要增加cpu。</span>
<span class="err">b 列表示在等待资源的进程数，比如正在等待I``/O``、或者内存交换等。</span>
<span class="err">-----------------------------</span>
<span class="err">cpu部分的解释</span>
<span class="err">us 列显示了用户方式下所花费 CPU 时间的百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，需要考虑优化用户的程序。</span>
<span class="err">sy 列显示了内核进程所花费的cpu时间的百分比。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足。</span>
<span class="err">wa 列显示了IO等待所占用的CPU时间的百分比。这里wa的参考值为30%，如果wa超过30%，说明IO等待严重，这可能是磁盘大量随机访问造成的，也可能磁盘或者</span>
<span class="err">  ``磁盘访问控制器的带宽瓶颈造成的(主要是块操作)。</span>
<span class="err">id` `列显示了cpu处在空闲状态的时间百分比</span>
<span class="err">-----------------------------</span>
<span class="err">system部分的解释</span>
<span class="err">in 列表示在某一时间间隔中观测到的每秒设备中断数。</span>
<span class="err">cs列表示每秒产生的上下文切换次数，如当 cs 比磁盘 I/O 和网络信息包速率高得多，都应进行进一步调查。</span>
<span class="err">-----------------------------</span>
<span class="err">memory部分的解释</span>
<span class="err">swpd 切换到内存交换区的内存数量(k表示)。如果swpd的值不为0，或者比较大，比如超过了100m，只要si、so的值长期为0，系统性能还是正常</span>
<span class="err">free 当前的空闲页面列表中内存数量(k表示)</span>
<span class="err">buff 作为buffer cache的内存数量，一般对块设备的读写才需要缓冲。</span>
<span class="c">cache: 作为page cache的内存数量，一般作为文件系统的cache，如果cache较大，说明用到cache的文件较多，如果此时IO中bi比较小，说明文件系统效率比较好。</span>
<span class="err">-----------------------------</span>
<span class="err">swap部分的解释</span>
<span class="err">si 由内存进入内存交换区数量。</span>
<span class="err">so由内存交换区进入内存数量。</span>
<span class="err">-----------------------------</span>
<span class="err">IO部分的解释</span>
<span class="err">bi 从块设备读入数据的总量（读磁盘）（每秒kb）。</span>
<span class="err">bo 块设备写入数据的总量（写磁盘）（每秒kb）</span>
</code></pre></div>


<h4>Procs</h4>
<p>procs有 <strong>r</strong>列和<strong>b</strong>列。<strong>r</strong>列代表等待访问CPU的进程数量。而b列意味着睡眠进程的数量。在这些列的下面，是它们的值。从上面的截图中，我门有2个进程正在等待访问CPU，0个睡眠进程。</p>
<h4>Memory</h4>
<p>memory有<strong>swpd、 free、 buff</strong> 和 <strong>cache</strong> 这些列。这些信息和命令<strong>free -m</strong>相同。<strong>swpd列</strong>显示了有多少内存已经被交换到了交换文件或者磁盘。<strong>free列</strong>显示了未分配的可用内存。<strong>buff列</strong>显示了使用中的内存。<strong>cache列</strong>显示了有多少内存可以被交换到交换文件或者磁盘上如果一些应用需要他们。</p>
<h4>Swap</h4>
<p>swap显示了从交换系统上发送或取回了多少内存。<strong>si</strong>列告诉我们每秒有多少内存被<strong>从swap移到真实内存</strong>中（In）。<strong>so</strong>列告诉我们每秒有多少内存被<strong>从真实内存移到swap</strong>中（Out）。</p>
<h4>I/O</h4>
<p><strong>io</strong>依据块的读写显示了每秒输入输出的活动。<strong>bi</strong>列告诉我们收到的块数量，<strong>bo</strong>列告诉我们发送的块数量。</p>
<h4>System</h4>
<p>system显示了每秒的系统操作数量。<strong>in</strong>列显示了系统每秒被中断的数量。<strong>cs</strong>列显示了系统为了处理所以任务而上下文切换的数量。</p>
<h4>CPU</h4>
<p>CPU告诉了我们CPU资源的使用情况。<strong>us列</strong>显示了处理器在非内核程序消耗的时间。<strong>sy列</strong>显示了处理器在内核相关任务上消耗的时间。<strong>id列</strong>显示了处理器的空闲时间。<strong>wa列</strong>显示了处理器在等待IO操作完成以继续处理任务上的时间。</p>
<p><strong>ss</strong>是<strong>iproute2</strong>包的一部分。iproute2是用来替代一整套标准的<strong>Unix网络</strong>工具组件，它曾经用来完成<a href="http://linux.cn/article-4372-1.html">网络接口配置，路由表和管理ARP表</a>任务。ss工具用来记录套接字统计信息，它可以显示类似netstat一样的信息，同时也能显示更多TCP和状态信息。一些例子如下：</p>
<div class="highlight"><pre><span></span><code>ss -tnap
ss -tnap6
ss -tnap
ss -s
ss -tn -o state established -p
</code></pre></div>


<p><strong>lsof</strong>命令，意为“<strong>list open files</strong>”, 用于在许多类Unix系统中显示所有打开的文件及打开它们的进程。在大部分Linux发行版和其他类Linux操作系统中系统管理员用它来检查不同的进程打开了哪些文件。</p>
<div class="highlight"><pre><span></span><code><span class="c1"># lsof +p process_id</span>
<span class="c1"># lsof | less</span>
<span class="c1"># lsof –u username</span>
<span class="c1"># lsof /etc/passwd</span>
<span class="c1"># lsof –i TCP:ftp</span>
<span class="c1"># lsof –i TCP:80</span>
</code></pre></div>


<p>缓冲区与特定的块设备关联，并覆盖文件系统元数据的缓存以及跟踪运行中的页面。缓存仅包含驻留的文件数据。也就是说，缓冲区记住目录中的内容，文件权限是什么，并跟踪从特定块设备写入或读取的内存。缓存仅包含文件本身的内容。</p>
<p>“缓冲区”表示有多少RAM专用于缓存磁盘块。“缓存”类似于“缓冲区”，只是这次它缓存文件读取中的页面。</p>
<p><a href="http://www.quora.com/What-is-the-difference-between-Buffers-and-Cached-columns-in-proc-meminfo-output">
引用答案（供参考）：</a></p>
<blockquote>
<p>简短答案：高速缓存是页面高速缓存的大小。缓冲区是内存中块I / O缓冲区的大小。缓存的事项；缓冲区在很大程度上无关紧要。</p>
<p>长答案：缓存是Linux页面缓存的大小减去交换缓存中的内存，它由SwapCached表示（因此总页面缓存大小为Cached + SwapCached）。Linux通过页面缓存执行所有文件I / O。写操作的实现是简单地将页面缓存中的相应页面标记为脏。然后，刷新程序线程会定期将所有脏页写回到磁盘。通过从页面缓存返回数据来实现读取。如果数据尚未在高速缓存中，则首先填充它。在现代Linux系统上，“缓存”可以轻松达到数GB。它只会响应内存压力而缩小。系统将清除页面缓存以及将数据交换到磁盘上，以根据需要提供更多的内存。</p>
<p>缓冲区是内存中的块I / O缓冲区。他们是相对短暂的。在Linux内核版本2.4之前，Linux具有单独的页面和缓冲区高速缓存。从2.4开始，页面和缓冲区高速缓存是统一的，缓冲区是未在页面高速缓存中表示的原始磁盘块，即不是文件数据。因此，“缓冲区”度量标准的重要性最低。在大多数系统上，缓冲区通常只有几十兆字节。</p>
</blockquote>
<p>它并不像这样简单，但是可能有助于理解：</p>
<p>缓冲区用于存储文件元数据（权限，位置等）。每个内存页面都在此处跟踪。</p>
<p>缓存用于存储实际文件内容。</p>
<p>iostat </p>
<div class="highlight"><pre><span></span><code><span class="err">解释说明：</span>
<span class="n">avg</span><span class="o">-</span><span class="nl">cpu</span><span class="p">:</span> <span class="err">总体</span><span class="n">cpu使用情况统计信息</span><span class="err">，对于多核</span><span class="n">cpu</span><span class="err">，这里为所有</span><span class="n">cpu的平均值</span>
<span class="nf">%user</span><span class="o">:</span> <span class="err">在用户级别运行所使用的</span><span class="n">CPU的百分比</span><span class="p">.</span>
<span class="o">%</span><span class="err">``</span><span class="n">nice</span><span class="err">``</span><span class="o">:</span> <span class="err">``</span><span class="n">nice</span><span class="err">``操作所使用的</span><span class="n">CPU的百分比</span><span class="p">.</span>
<span class="nf">%sys</span><span class="o">:</span> <span class="err">在系统级别</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span><span class="err">运行所使用</span><span class="n">CPU的百分比</span><span class="p">.</span>
<span class="nf">%iowait</span><span class="o">:</span> <span class="n">CPU等待硬件I</span><span class="err">``</span><span class="o">/</span><span class="n">O</span><span class="err">``时</span><span class="p">,</span><span class="err">所占用</span><span class="n">CPU百分比</span><span class="p">.</span>
<span class="nf">%idle</span><span class="o">:</span> <span class="n">CPU空闲时间的百分比</span><span class="p">.</span>

<span class="nl">Device段</span><span class="p">:</span><span class="err">各磁盘设备的</span><span class="n">IO统计信息</span>
<span class="nl">tps</span><span class="p">:</span> <span class="err">每秒钟发送到的</span><span class="n">I</span><span class="err">``</span><span class="o">/</span><span class="n">O</span><span class="err">``请求数</span><span class="p">.</span>
<span class="n">Blk_read</span> <span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒读取的</span><span class="n">block数</span><span class="p">.</span>
<span class="n">Blk_wrtn</span><span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒写入的</span><span class="n">block数</span><span class="p">.</span>
<span class="nl">Blk_read</span><span class="p">:</span>  <span class="err">读入的</span><span class="n">block总数</span><span class="p">.</span>
<span class="nl">Blk_wrtn</span><span class="p">:</span> <span class="err">写入的</span><span class="n">block总数</span><span class="p">.</span>
</code></pre></div>


<p>iostat -x -k -d 1</p>
<div class="highlight"><pre><span></span><code><span class="err">解释说明：</span>
<span class="n">rrqm</span><span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒对该设备的读请求被合并次数，文件系统会对读取同块</span><span class="p">(</span><span class="n">block</span><span class="p">)</span><span class="err">的请求进行合并</span>
<span class="n">wrqm</span><span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒对该设备的写请求被合并次数</span>
<span class="n">r</span><span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒完成的读次数</span>
<span class="n">w</span><span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒完成的写次数</span>
<span class="n">rkB</span><span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒读数据量</span><span class="p">(</span><span class="n">kB为单位</span><span class="p">)</span>
<span class="n">wkB</span><span class="err">``</span><span class="o">/</span><span class="n">s</span><span class="err">``</span><span class="o">:</span> <span class="err">每秒写数据量</span><span class="p">(</span><span class="n">kB为单位</span><span class="p">)</span>
<span class="n">avgrq</span><span class="o">-</span><span class="nl">sz</span><span class="p">:</span><span class="err">平均每次</span><span class="n">IO操作的数据量</span><span class="p">(</span><span class="err">扇区数为单位</span><span class="p">)</span>
<span class="n">avgqu</span><span class="o">-</span><span class="nl">sz</span><span class="p">:</span> <span class="err">平均等待处理的</span><span class="n">IO请求队列长度</span>
<span class="nl">await</span><span class="p">:</span> <span class="err">平均每次</span><span class="n">IO请求等待时间</span><span class="p">(</span><span class="err">包括等待时间和处理时间，毫秒为单位</span><span class="p">)</span>
<span class="nl">svctm</span><span class="p">:</span> <span class="err">平均每次</span><span class="n">IO请求的处理时间</span><span class="p">(</span><span class="err">毫秒为单位</span><span class="p">)</span>
<span class="nf">%util</span><span class="o">:</span> <span class="err">采用周期内用于</span><span class="n">IO操作的时间比率</span><span class="err">，即</span><span class="n">IO队列非空的时间比率</span>

<span class="err">如果</span> <span class="nf">%util</span> <span class="err">接近</span> <span class="mi">100</span><span class="o">%</span><span class="err">，说明产生的</span><span class="n">I</span><span class="err">``</span><span class="o">/</span><span class="n">O</span><span class="err">``请求太多，</span><span class="n">I</span><span class="err">``</span><span class="o">/</span><span class="n">O</span><span class="err">``系统已经满负荷，该磁盘可能存在瓶颈。</span>
<span class="n">idle小于70</span><span class="o">%</span> <span class="n">IO压力就较大了</span><span class="p">,</span><span class="err">一般读取速度有较多的</span><span class="n">wait</span><span class="err">。</span>
<span class="err">同时可以结合</span><span class="n">vmstat</span> <span class="err">查看查看</span><span class="n">b参数</span><span class="p">(</span><span class="err">等待资源的进程数</span><span class="p">)</span><span class="err">和</span><span class="n">wa参数</span><span class="p">(</span><span class="n">IO等待所占用的CPU时间的百分比</span><span class="p">,</span><span class="err">高过</span><span class="mi">30</span><span class="o">%</span><span class="err">时</span><span class="n">IO压力高</span><span class="p">)</span>
</code></pre></div>


<p>在Linux系统中，为了提高文件系统性能，内核利用一部分物理内存分配出缓冲区，用于缓存系统操作和数据文件，当内核收到读写的请求时，内核先去缓存区找是否有请求的数据，有就直接返回，如果没有则通过驱动程序直接操作磁盘。
缓存机制优点：减少系统调用次数，降低CPU上下文切换和磁盘访问频率。
CPU上下文切换：CPU给每个进程一定的服务时间，当时间片用完后，内核从正在运行的进程中收回处理器，同时把进程当前运行状态保存下来，然后加载下一个任务，这个过程叫做上下文切换。实质上就是被终止运行进程与待运行进程的进程切换。</p>
<p>Swap用途：Swap意思是交换分区，通常我们说的虚拟内存，是从硬盘中划分出的一个分区。当物理内存不够用的时候，内核就会释放缓存区（buffers/cache）里一些长时间不用的程序，然后将这些程序临时放到Swap中，也就是说如果物理内存和缓存区内存不够用的时候，才会用到Swap。
swap清理：swapoff -a &amp;&amp; swapon -a
注意：这样清理有个前提条件，空闲的内存必须比已经使用的swap空间大</p>
<div class="highlight"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">查看内存使用情况</span><span class="err">，</span><span class="n">发现swap虚拟内存空间竟然为0</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"> </span>
<span class="mf">2.</span><span class="w"> </span><span class="n">建虚拟内存磁盘卷</span><span class="err">。</span><span class="n">做法如下</span><span class="err">：</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">dd</span><span class="w"> </span><span class="k">if</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">zero</span><span class="w"> </span><span class="k">of</span><span class="o">=/</span><span class="n">opt</span><span class="o">/</span><span class="n">swap</span><span class="w"> </span><span class="n">bs</span><span class="o">=</span><span class="mi">1024</span><span class="w"> </span><span class="nf">count</span><span class="o">=</span><span class="mi">2048000</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">mkswap</span><span class="w"> </span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">swap</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">swapon</span><span class="w"> </span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">swap</span><span class="w"></span>

<span class="n">再次查看内容</span><span class="err">，</span><span class="n">发现swap虚拟内存就有了</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"></span>

<span class="mf">3.</span><span class="w"> </span><span class="n">如果想取消文件虚拟内存</span><span class="err">，</span><span class="n">即删除swap</span><span class="err">，</span><span class="n">做法如下</span><span class="err">：（</span><span class="n">当然根据系统配置</span><span class="err">，</span><span class="n">也可以保留swap</span><span class="err">，</span><span class="n">以后继续用</span><span class="err">）。</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">swapoff</span><span class="w"> </span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">swap</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">rm</span><span class="w"> </span><span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">swap</span><span class="w"></span>

<span class="mf">4.</span><span class="w"> </span><span class="n">swap开机挂载</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">vim</span><span class="w"> </span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">fstab</span><span class="w"></span>
<span class="o">/</span><span class="n">opt</span><span class="o">/</span><span class="n">swap</span><span class="w">  </span><span class="n">swap</span><span class="w">                    </span><span class="n">swap</span><span class="w">    </span><span class="n">defaults</span><span class="w">        </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="n">上面挂载参数分别为</span><span class="err">：</span><span class="w"></span>
<span class="n">设备文件或伪文件系统</span><span class="w">   </span><span class="n">挂载点</span><span class="w">  </span><span class="n">文件系统类型</span><span class="w">  </span><span class="n">挂载选项</span><span class="w"> </span><span class="n">备份频率</span><span class="w"> </span><span class="n">开机自检次序</span><span class="w"></span>


<span class="mf">6.</span><span class="w"> </span><span class="n">移动虚拟内存空间</span><span class="w"></span>
<span class="n">如果当前的虚存所在的磁盘空间不够</span><span class="err">，</span><span class="n">可以首先关闭虚存服务</span><span class="err">，</span><span class="n">将其移动到别的磁盘</span><span class="err">，</span><span class="n">再启用即可</span><span class="err">。</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">swapoff</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="o">/</span><span class="n">swap</span><span class="o">/</span><span class="n">swapadd</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">mv</span><span class="w"> </span><span class="o">/</span><span class="n">swap</span><span class="o">/</span><span class="n">swapadd</span><span class="w"> </span><span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">swap</span><span class="w"></span>
<span class="err">#</span><span class="w"> </span><span class="n">swapon</span><span class="w"> </span><span class="o">/</span><span class="n">swap</span><span class="o">/</span><span class="n">swapadd</span><span class="w"></span>



<span class="n">释放缓存区内存的方法</span><span class="w"></span>
<span class="mi">1</span><span class="err">）</span><span class="n">清理pagecache</span><span class="err">（</span><span class="n">页面缓存</span><span class="err">）</span><span class="w"></span>
<span class="o">[</span><span class="n">root@backup ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">/</span><span class="k">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">drop_caches</span><span class="w">     </span><span class="n">或者</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">sysctl</span><span class="w"> </span><span class="o">-</span><span class="n">w</span><span class="w"> </span><span class="n">vm</span><span class="p">.</span><span class="n">drop_caches</span><span class="o">=</span><span class="mi">1</span><span class="w"></span>

<span class="mi">2</span><span class="err">）</span><span class="n">清理dentries</span><span class="err">（</span><span class="n">目录缓存</span><span class="err">）</span><span class="n">和inodes</span><span class="w"></span>
<span class="o">[</span><span class="n">root@backup ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">/</span><span class="k">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">drop_caches</span><span class="w">     </span><span class="n">或者</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">sysctl</span><span class="w"> </span><span class="o">-</span><span class="n">w</span><span class="w"> </span><span class="n">vm</span><span class="p">.</span><span class="n">drop_caches</span><span class="o">=</span><span class="mi">2</span><span class="w"></span>

<span class="mi">3</span><span class="err">）</span><span class="n">清理pagecache</span><span class="err">、</span><span class="n">dentries和inodes</span><span class="w"></span>
<span class="o">[</span><span class="n">root@backup ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">echo</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">/</span><span class="k">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">drop_caches</span><span class="w">     </span><span class="n">或者</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">sysctl</span><span class="w"> </span><span class="o">-</span><span class="n">w</span><span class="w"> </span><span class="n">vm</span><span class="p">.</span><span class="n">drop_caches</span><span class="o">=</span><span class="mi">3</span><span class="w"></span>
<span class="w">　</span>
<span class="n">上面三种方式都是临时释放缓存的方法</span><span class="err">，</span><span class="n">要想永久释放缓存</span><span class="err">，</span><span class="n">需要在</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">sysctl</span><span class="p">.</span><span class="n">conf文件中配置</span><span class="err">：</span><span class="n">vm</span><span class="p">.</span><span class="n">drop_caches</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="err">，</span><span class="n">然后sysctl</span><span class="w"> </span><span class="o">-</span><span class="n">p生效即可</span><span class="err">！</span><span class="w"></span>

<span class="n">另外</span><span class="err">，</span><span class="n">可以使用sync命令来清理文件系统缓存</span><span class="err">，</span><span class="n">还会清理僵尸</span><span class="p">(</span><span class="n">zombie</span><span class="p">)</span><span class="n">对象和它们占用的内存</span><span class="w"></span>
<span class="o">[</span><span class="n">root@backup ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">sync</span><span class="w"></span>


<span class="n">温馨提示</span><span class="err">：</span><span class="w"></span>
<span class="n">上面操作在大多数情况下都不会对系统造成伤害</span><span class="err">，</span><span class="n">只会有助于释放不用的内存</span><span class="err">。</span><span class="w"></span>
<span class="n">但是如果在执行这些操作时正在写数据</span><span class="err">，</span><span class="n">那么实际上在数据到达磁盘之前就将它从文件缓存中清除掉了</span><span class="err">，</span><span class="n">这可能会造成很不好的影响</span><span class="err">。</span><span class="w"></span>

<span class="n">那么如果避免这种事情发生呢</span><span class="err">？</span><span class="w"></span>
<span class="n">因此</span><span class="err">，</span><span class="n">这里不得不提一下</span><span class="o">/</span><span class="k">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">vfs_cache_pressure这个文件</span><span class="err">，</span><span class="n">告诉内核</span><span class="err">，</span><span class="n">当清理inoe</span><span class="o">/</span><span class="n">dentry缓存时应该用什么样的优先级</span><span class="err">。</span><span class="w"></span>
<span class="o">[</span><span class="n">root@backup ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">/</span><span class="k">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">vm</span><span class="o">/</span><span class="n">vfs_cache_pressure</span><span class="w"></span>
<span class="mi">100</span><span class="w"></span>

<span class="n">vfs_cache_pressure</span><span class="o">=</span><span class="mi">100</span><span class="w">    </span><span class="n">这个是默认值</span><span class="err">，</span><span class="n">内核会尝试重新声明dentries和inodes</span><span class="err">，</span><span class="n">并采用一种相对于页面缓存和交换缓存比较</span><span class="ss">&quot;合理&quot;</span><span class="n">的比例</span><span class="err">。</span><span class="w"></span>

<span class="n">减少vfs_cache_pressure的值</span><span class="err">，</span><span class="n">会导致内核倾向于保留dentry和inode缓存</span><span class="err">。</span><span class="w"></span>
<span class="n">增加vfs_cache_pressure的值</span><span class="err">，（</span><span class="n">即超过100时</span><span class="err">），</span><span class="n">则会导致内核倾向于重新声明dentries和inodes</span><span class="w"></span>

<span class="n">总之</span><span class="err">，</span><span class="n">vfs_cache_pressure的值</span><span class="err">：</span><span class="w"></span>
<span class="n">小于100的值不会导致缓存的大量减少</span><span class="w"></span>
<span class="n">超过100的值则会告诉内核你希望以高优先级来清理缓存</span><span class="err">。</span><span class="w"></span>

<span class="n">其实无论vfs_cache_pressure的值采用什么值</span><span class="err">，</span><span class="n">内核清理缓存的速度都是比较低的</span><span class="err">。</span><span class="w"></span>
<span class="n">如果将此值设置为10000</span><span class="err">，</span><span class="n">系统将会将缓存减少到一个合理的水平</span><span class="err">。</span><span class="w"></span>
</code></pre></div>


<p>测试硬盘写入速度</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@redhat73 ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">dd</span><span class="w"> </span><span class="k">if</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">zero</span><span class="w"> </span><span class="k">of</span><span class="o">=/</span><span class="n">home</span><span class="o">/</span><span class="n">linshi</span><span class="p">.</span><span class="n">a</span><span class="w"> </span><span class="n">bs</span><span class="o">=</span><span class="mi">1024000000</span><span class="w"> </span><span class="nf">count</span><span class="o">=</span><span class="mi">2</span><span class="w"></span>
<span class="mi">2</span><span class="o">+</span><span class="mi">0</span><span class="w"> </span><span class="n">records</span><span class="w"> </span><span class="ow">in</span><span class="w"></span>
<span class="mi">2</span><span class="o">+</span><span class="mi">0</span><span class="w"> </span><span class="n">records</span><span class="w"> </span><span class="k">out</span><span class="w"></span>
<span class="mi">2048000000</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="n">GB</span><span class="p">)</span><span class="w"> </span><span class="n">copied</span><span class="p">,</span><span class="w"> </span><span class="mf">4.67577</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="mi">438</span><span class="w"> </span><span class="n">MB</span><span class="o">/</span><span class="n">s</span><span class="w"></span>

<span class="n">写入一个2GB的文件</span><span class="err">，</span><span class="n">用时4</span><span class="mf">.67577</span><span class="n">秒</span><span class="err">，</span><span class="n">平均438</span><span class="w"> </span><span class="n">MB</span><span class="o">/</span><span class="n">s</span><span class="w"></span>
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@localhost home</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="o">-</span><span class="n">h</span><span class="w"></span>
<span class="w">              </span><span class="n">total</span><span class="w">        </span><span class="n">used</span><span class="w">        </span><span class="k">free</span><span class="w">      </span><span class="n">shared</span><span class="w">  </span><span class="n">buff</span><span class="o">/</span><span class="n">cache</span><span class="w">   </span><span class="n">available</span><span class="w"></span>
<span class="nl">Mem</span><span class="p">:</span><span class="w">           </span><span class="mi">974</span><span class="n">M</span><span class="w">         </span><span class="mi">56</span><span class="n">M</span><span class="w">        </span><span class="mi">818</span><span class="n">M</span><span class="w">        </span><span class="mi">580</span><span class="n">K</span><span class="w">         </span><span class="mi">99</span><span class="n">M</span><span class="w">        </span><span class="mi">787</span><span class="n">M</span><span class="w"></span>
<span class="nl">Swap</span><span class="p">:</span><span class="w">          </span><span class="mf">2.0</span><span class="n">G</span><span class="w">         </span><span class="mi">37</span><span class="n">M</span><span class="w">        </span><span class="mf">2.0</span><span class="n">G</span><span class="w"></span>

<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">参数解释</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="n">m</span><span class="w">      </span><span class="n">以MB为单位输出</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="n">g</span><span class="w">      </span><span class="n">以GB为单位输出</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="n">h</span><span class="w">      </span><span class="n">以人类可读的单位输出</span><span class="err">，</span><span class="n">自动转换KB</span><span class="err">、</span><span class="n">MB或者GB为单位</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="n">s</span><span class="w"> </span><span class="n">N</span><span class="w">    </span><span class="n">每N秒打印一次</span><span class="w"></span>
<span class="w">    </span><span class="o">-</span><span class="n">c</span><span class="w"> </span><span class="n">N</span><span class="w">    </span><span class="n">打印N次后退出</span><span class="w"></span>


<span class="err">#</span><span class="w"> </span><span class="n">输出说明</span><span class="err">（</span><span class="n">Mem代表物理内存</span><span class="err">、</span><span class="n">Swap代表虚拟内存</span><span class="err">）</span><span class="w"></span>
<span class="n">total</span><span class="w">       </span><span class="n">表示系统的总内存</span><span class="w"></span>
<span class="n">used</span><span class="w">        </span><span class="n">表示应用程序已经使用的内存</span><span class="w"></span>
<span class="k">free</span><span class="w">        </span><span class="n">表示当前还没有被使用的内存</span><span class="w"> </span>
<span class="n">shared</span><span class="w">      </span><span class="n">表示共享链接库使用的内存</span><span class="w"></span>
<span class="n">buff</span><span class="o">/</span><span class="n">cache</span><span class="w">  </span><span class="n">表示系统的page</span><span class="w"> </span><span class="n">cache和buffer使用到的内存</span><span class="w"></span>
<span class="n">available</span><span class="w">   </span><span class="n">表示应用程序还可以申请到的内存</span><span class="w"></span>

<span class="n">怎么判断是否需要加内存</span><span class="err">：</span><span class="w"></span>
<span class="w">    </span><span class="mf">1.</span><span class="n">swap使用有多少</span><span class="w"></span>
<span class="w">    </span><span class="mf">2.</span><span class="n">available剩余是多少</span><span class="err">，</span><span class="n">而不是看free</span><span class="w"></span>

<span class="n">cache是Linux系统为了提高系统运行效率而将一些程序或文件写入到cache</span><span class="err">，</span><span class="n">可提高程序运行和加载速度</span><span class="err">，</span><span class="n">如果程序需要会马上释放</span><span class="err">。</span><span class="n">所以判断系统内存是否足够和是否需要增加的时候不能简单的看free</span><span class="w"></span>
<span class="n">Cache</span><span class="w"> </span><span class="nl">Pages</span><span class="p">:</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">transparently</span><span class="w"> </span><span class="n">stores</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="n">requests</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">served</span><span class="w"> </span><span class="n">faster</span><span class="p">.</span><span class="w"> </span>
<span class="w">    </span><span class="n">This</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">utilized</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="k">disk</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">improve</span><span class="w"> </span><span class="n">i</span><span class="o">/</span><span class="n">o</span><span class="w"> </span><span class="n">performance</span><span class="p">.</span><span class="w"></span>


<span class="n">系统当前使用到的内存是</span><span class="err">：</span><span class="n">used</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">buff</span><span class="o">/</span><span class="n">cache</span><span class="err">，</span><span class="n">used中包含了shared</span><span class="err">。</span><span class="w"></span>
<span class="n">所以total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">buff</span><span class="o">/</span><span class="n">cache</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">56</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">818</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">973</span><span class="w"></span>
<span class="n">available</span><span class="err">（</span><span class="mi">787</span><span class="err">）</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">buff</span><span class="o">/</span><span class="n">cache</span><span class="err">（</span><span class="mi">818</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">99</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">917</span><span class="err">），</span><span class="n">为什么是小于呢</span><span class="err">？</span><span class="n">因为系统的一些page或cache是不能回收的</span><span class="err">。</span><span class="w"></span>
</code></pre></div>


<div class="highlight"><pre><span></span><code><span class="err">查看</span><span class="n">CPU信息</span>
<span class="o">#</span> <span class="err">总核数</span> <span class="o">=</span> <span class="err">物理</span><span class="n">CPU个数</span> <span class="n">X</span> <span class="err">每颗物理</span><span class="n">CPU的核数</span> 
<span class="o">#</span> <span class="err">总逻辑</span><span class="n">CPU数</span> <span class="o">=</span> <span class="err">物理</span><span class="n">CPU个数</span> <span class="n">X</span> <span class="err">每颗物理</span><span class="n">CPU的核数</span> <span class="n">X</span> <span class="err">超线程数</span>

<span class="o">#</span> <span class="err">查看物理</span><span class="n">CPU个数</span>
<span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">cpuinfo</span><span class="o">|</span> <span class="n">grep</span> <span class="ss">&quot;physical id&quot;</span><span class="o">|</span> <span class="n">sort</span><span class="o">|</span> <span class="n">uniq</span><span class="o">|</span> <span class="n">wc</span> <span class="o">-</span><span class="n">l</span>

<span class="o">#</span> <span class="err">查看每个物理</span><span class="n">CPU中core的个数</span><span class="p">(</span><span class="err">即核数</span><span class="p">)</span>
<span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">cpuinfo</span><span class="o">|</span> <span class="n">grep</span> <span class="ss">&quot;cpu cores&quot;</span><span class="o">|</span> <span class="n">uniq</span>

<span class="o">#</span> <span class="err">查看逻辑</span><span class="n">CPU的个数</span>
<span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">cpuinfo</span><span class="o">|</span> <span class="n">grep</span> <span class="ss">&quot;processor&quot;</span><span class="o">|</span> <span class="n">wc</span> <span class="o">-</span><span class="n">l</span>

<span class="o">#</span> <span class="err">查看</span><span class="n">CPU信息</span><span class="err">（型号）</span>
<span class="n">cat</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">cpuinfo</span> <span class="o">|</span> <span class="n">grep</span> <span class="n">name</span> <span class="o">|</span> <span class="n">cut</span> <span class="o">-</span><span class="n">f2</span> <span class="o">-</span><span class="n">d</span><span class="p">:</span> <span class="o">|</span> <span class="n">uniq</span> <span class="o">-</span><span class="k">c</span>
</code></pre></div>


<p>性能测评工具</p>
<p><img alt="img" src="/img/f_297d3a62fcd5803f272e98a23b4df300.png"></p>
<p>性能调优工具</p>
<p><img alt="img" src="/img/f_3552705daa99f0be64ab0261c7d04221.png"></p>
<h3>参考</h3>
<p><a href="https://www.infoq.cn/article/2015/12/linux-performance">用十条命令在一分钟内检查Linux服务器性能</a></p>
<p><a href="https://linux.cn/article-4481-1.html">你值得拥有 —— 25 个 Linux 性能监控工具</a></p>
<p><a href="https://linux.cn/article-2352-1.html">Top命令详解</a></p>
<p><a href="https://linux.cn/article-4099-1.html">gglsof命令入门</a></p>
<p><a href="https://www.cnblogs.com/kevingrace/p/5991604.html">Linux缓存机制</a></p>
<p><a href="https://linux.cn/article-2352-1.html">30个实例详解TOP命令</a></p>
<p><a href="https://linux.cn/article-4099-1.html">lsof命令行神器入门</a></p>
<p><a href="https://rdc.hundsun.com/portal/article/731.html">超全整理！Linux性能分析工具汇总合集</a></p>

      </div><!-- /.entry-content -->
      <div class="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_identifier = "pages/2020/10/17/Linux-Peformence-Test/";
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//niuhemoon.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
      </div>

    </article>
  </section>
</div>
            </div>
        </div>
    </div>

    <footer id="site-footer">
        <div class="row-fluid">
            <div class="span10 offset1">
                <address>
                    <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                    </p>
                    <p>
                        <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                    </p>
                </address>
            </div>
        </div>
    </footer>

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-116933089-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'niuhemoon';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
    <script src="//code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>
</body>
</html>